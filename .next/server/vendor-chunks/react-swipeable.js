"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-swipeable";
exports.ids = ["vendor-chunks/react-swipeable"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-swipeable/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/react-swipeable/es/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOWN: () => (/* binding */ DOWN),\n/* harmony export */   LEFT: () => (/* binding */ LEFT),\n/* harmony export */   RIGHT: () => (/* binding */ RIGHT),\n/* harmony export */   UP: () => (/* binding */ UP),\n/* harmony export */   useSwipeable: () => (/* binding */ useSwipeable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst LEFT = \"Left\";\nconst RIGHT = \"Right\";\nconst UP = \"Up\";\nconst DOWN = \"Down\";\n/* global document */ const defaultProps = {\n    delta: 10,\n    preventScrollOnSwipe: false,\n    rotationAngle: 0,\n    trackMouse: false,\n    trackTouch: true,\n    swipeDuration: Infinity,\n    touchEventOptions: {\n        passive: true\n    }\n};\nconst initialState = {\n    first: true,\n    initial: [\n        0,\n        0\n    ],\n    start: 0,\n    swiping: false,\n    xy: [\n        0,\n        0\n    ]\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\nfunction getDirection(absX, absY, deltaX, deltaY) {\n    if (absX > absY) {\n        if (deltaX > 0) {\n            return RIGHT;\n        }\n        return LEFT;\n    } else if (deltaY > 0) {\n        return DOWN;\n    }\n    return UP;\n}\nfunction rotateXYByAngle(pos, angle) {\n    if (angle === 0) return pos;\n    const angleInRadians = Math.PI / 180 * angle;\n    const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n    const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n    return [\n        x,\n        y\n    ];\n}\nfunction getHandlers(set, handlerProps) {\n    const onStart = (event)=>{\n        const isTouch = \"touches\" in event;\n        // if more than a single touch don't track, for now...\n        if (isTouch && event.touches.length > 1) return;\n        set((state, props)=>{\n            // setup mouse listeners on document to track swipe since swipe can leave container\n            if (props.trackMouse && !isTouch) {\n                document.addEventListener(mouseMove, onMove);\n                document.addEventListener(mouseUp, onUp);\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const xy = rotateXYByAngle([\n                clientX,\n                clientY\n            ], props.rotationAngle);\n            props.onTouchStartOrOnMouseDown && props.onTouchStartOrOnMouseDown({\n                event\n            });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n                initial: xy.slice(),\n                xy,\n                start: event.timeStamp || 0\n            });\n        });\n    };\n    const onMove = (event)=>{\n        set((state, props)=>{\n            const isTouch = \"touches\" in event;\n            // Discount a swipe if additional touches are present after\n            // a swipe has started.\n            if (isTouch && event.touches.length > 1) {\n                return state;\n            }\n            // if swipe has exceeded duration stop tracking\n            if (event.timeStamp - state.start > props.swipeDuration) {\n                return state.swiping ? Object.assign(Object.assign({}, state), {\n                    swiping: false\n                }) : state;\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const [x, y] = rotateXYByAngle([\n                clientX,\n                clientY\n            ], props.rotationAngle);\n            const deltaX = x - state.xy[0];\n            const deltaY = y - state.xy[1];\n            const absX = Math.abs(deltaX);\n            const absY = Math.abs(deltaY);\n            const time = (event.timeStamp || 0) - state.start;\n            const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n            const vxvy = [\n                deltaX / (time || 1),\n                deltaY / (time || 1)\n            ];\n            const dir = getDirection(absX, absY, deltaX, deltaY);\n            // if swipe is under delta and we have not started to track a swipe: skip update\n            const delta = typeof props.delta === \"number\" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;\n            if (absX < delta && absY < delta && !state.swiping) return state;\n            const eventData = {\n                absX,\n                absY,\n                deltaX,\n                deltaY,\n                dir,\n                event,\n                first: state.first,\n                initial: state.initial,\n                velocity,\n                vxvy\n            };\n            // call onSwipeStart if present and is first swipe event\n            eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n            // call onSwiping if present\n            props.onSwiping && props.onSwiping(eventData);\n            // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n            // so we can call preventDefault if needed\n            let cancelablePageSwipe = false;\n            if (props.onSwiping || props.onSwiped || props[`onSwiped${dir}`]) {\n                cancelablePageSwipe = true;\n            }\n            if (cancelablePageSwipe && props.preventScrollOnSwipe && props.trackTouch && event.cancelable) {\n                event.preventDefault();\n            }\n            return Object.assign(Object.assign({}, state), {\n                // first is now always false\n                first: false,\n                eventData,\n                swiping: true\n            });\n        });\n    };\n    const onEnd = (event)=>{\n        set((state, props)=>{\n            let eventData;\n            if (state.swiping && state.eventData) {\n                // if swipe is less than duration fire swiped callbacks\n                if (event.timeStamp - state.start < props.swipeDuration) {\n                    eventData = Object.assign(Object.assign({}, state.eventData), {\n                        event\n                    });\n                    props.onSwiped && props.onSwiped(eventData);\n                    const onSwipedDir = props[`onSwiped${eventData.dir}`];\n                    onSwipedDir && onSwipedDir(eventData);\n                }\n            } else {\n                props.onTap && props.onTap({\n                    event\n                });\n            }\n            props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({\n                event\n            });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n                eventData\n            });\n        });\n    };\n    const cleanUpMouse = ()=>{\n        // safe to just call removeEventListener\n        document.removeEventListener(mouseMove, onMove);\n        document.removeEventListener(mouseUp, onUp);\n    };\n    const onUp = (e)=>{\n        cleanUpMouse();\n        onEnd(e);\n    };\n    /**\n     * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n     * - true => { passive: false }\n     * - false => { passive: true } // Default\n     *\n     * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n     *\n     * props.touchEventOptions can also be set for all touch event listeners,\n     * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n     * supersede and force passive to false.\n     *\n     */ const attachTouch = (el, props)=>{\n        let cleanup = ()=>{};\n        if (el && el.addEventListener) {\n            const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);\n            // attach touch event listeners and handlers\n            const tls = [\n                [\n                    touchStart,\n                    onStart,\n                    baseOptions\n                ],\n                // preventScrollOnSwipe option supersedes touchEventOptions.passive\n                [\n                    touchMove,\n                    onMove,\n                    Object.assign(Object.assign({}, baseOptions), props.preventScrollOnSwipe ? {\n                        passive: false\n                    } : {})\n                ],\n                [\n                    touchEnd,\n                    onEnd,\n                    baseOptions\n                ]\n            ];\n            tls.forEach(([e, h, o])=>el.addEventListener(e, h, o));\n            // return properly scoped cleanup method for removing listeners, options not required\n            cleanup = ()=>tls.forEach(([e, h])=>el.removeEventListener(e, h));\n        }\n        return cleanup;\n    };\n    const onRef = (el)=>{\n        // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n        // ignore null here\n        if (el === null) return;\n        set((state, props)=>{\n            // if the same DOM el as previous just return state\n            if (state.el === el) return state;\n            const addState = {};\n            // if new DOM el clean up old DOM and reset cleanUpTouch\n            if (state.el && state.el !== el && state.cleanUpTouch) {\n                state.cleanUpTouch();\n                addState.cleanUpTouch = void 0;\n            }\n            // only attach if we want to track touch\n            if (props.trackTouch && el) {\n                addState.cleanUpTouch = attachTouch(el, props);\n            }\n            // store event attached DOM el for comparison, clean up, and re-attachment\n            return Object.assign(Object.assign(Object.assign({}, state), {\n                el\n            }), addState);\n        });\n    };\n    // set ref callback to attach touch event listeners\n    const output = {\n        ref: onRef\n    };\n    // if track mouse attach mouse down listener\n    if (handlerProps.trackMouse) {\n        output.onMouseDown = onStart;\n    }\n    return [\n        output,\n        attachTouch\n    ];\n}\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n    // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n    if (!props.trackTouch || !state.el) {\n        if (state.cleanUpTouch) {\n            state.cleanUpTouch();\n        }\n        return Object.assign(Object.assign({}, state), {\n            cleanUpTouch: undefined\n        });\n    }\n    // trackTouch is on, so if there are no handlers attached, attach them and exit\n    if (!state.cleanUpTouch) {\n        return Object.assign(Object.assign({}, state), {\n            cleanUpTouch: attachTouch(state.el, props)\n        });\n    }\n    // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n    // remove and reattach handlers (this is required to update the passive option when attaching\n    // the handlers)\n    if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe || props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n        state.cleanUpTouch();\n        return Object.assign(Object.assign({}, state), {\n            cleanUpTouch: attachTouch(state.el, props)\n        });\n    }\n    return state;\n}\nfunction useSwipeable(options) {\n    const { trackMouse } = options;\n    const transientState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Object.assign({}, initialState));\n    const transientProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Object.assign({}, defaultProps));\n    // track previous rendered props\n    const previousProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Object.assign({}, transientProps.current));\n    previousProps.current = Object.assign({}, transientProps.current);\n    // update current render props & defaults\n    transientProps.current = Object.assign(Object.assign({}, defaultProps), options);\n    // Force defaults for config properties\n    let defaultKey;\n    for(defaultKey in defaultProps){\n        if (transientProps.current[defaultKey] === void 0) {\n            transientProps.current[defaultKey] = defaultProps[defaultKey];\n        }\n    }\n    const [handlers, attachTouch] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>getHandlers((stateSetter)=>transientState.current = stateSetter(transientState.current, transientProps.current), {\n            trackMouse\n        }), [\n        trackMouse\n    ]);\n    transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n    return handlers;\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3dpcGVhYmxlL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFFL0IsTUFBTUMsT0FBTztBQUNiLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxLQUFLO0FBQ1gsTUFBTUMsT0FBTztBQUViLG1CQUFtQixHQUNuQixNQUFNQyxlQUFlO0lBQ2pCQyxPQUFPO0lBQ1BDLHNCQUFzQjtJQUN0QkMsZUFBZTtJQUNmQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsZUFBZUM7SUFDZkMsbUJBQW1CO1FBQUVDLFNBQVM7SUFBSztBQUN2QztBQUNBLE1BQU1DLGVBQWU7SUFDakJDLE9BQU87SUFDUEMsU0FBUztRQUFDO1FBQUc7S0FBRTtJQUNmQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVEMsSUFBSTtRQUFDO1FBQUc7S0FBRTtBQUNkO0FBQ0EsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxhQUFhO0FBQ25CLFNBQVNDLGFBQWFDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE1BQU07SUFDNUMsSUFBSUgsT0FBT0MsTUFBTTtRQUNiLElBQUlDLFNBQVMsR0FBRztZQUNaLE9BQU8zQjtRQUNYO1FBQ0EsT0FBT0Q7SUFDWCxPQUNLLElBQUk2QixTQUFTLEdBQUc7UUFDakIsT0FBTzFCO0lBQ1g7SUFDQSxPQUFPRDtBQUNYO0FBQ0EsU0FBUzRCLGdCQUFnQkMsR0FBRyxFQUFFQyxLQUFLO0lBQy9CLElBQUlBLFVBQVUsR0FDVixPQUFPRDtJQUNYLE1BQU1FLGlCQUFpQixLQUFNRSxFQUFFLEdBQUcsTUFBT0g7SUFDekMsTUFBTUksSUFBSUwsR0FBRyxDQUFDLEVBQUUsR0FBR0csS0FBS0csR0FBRyxDQUFDSixrQkFBa0JGLEdBQUcsQ0FBQyxFQUFFLEdBQUdHLEtBQUtJLEdBQUcsQ0FBQ0w7SUFDaEUsTUFBTU0sSUFBSVIsR0FBRyxDQUFDLEVBQUUsR0FBR0csS0FBS0csR0FBRyxDQUFDSixrQkFBa0JGLEdBQUcsQ0FBQyxFQUFFLEdBQUdHLEtBQUtJLEdBQUcsQ0FBQ0w7SUFDaEUsT0FBTztRQUFDRztRQUFHRztLQUFFO0FBQ2pCO0FBQ0EsU0FBU0MsWUFBWUMsR0FBRyxFQUFFQyxZQUFZO0lBQ2xDLE1BQU1DLFVBQVUsQ0FBQ0M7UUFDYixNQUFNQyxVQUFVLGFBQWFEO1FBQzdCLHNEQUFzRDtRQUN0RCxJQUFJQyxXQUFXRCxNQUFNRSxPQUFPLENBQUNDLE1BQU0sR0FBRyxHQUNsQztRQUNKTixJQUFJLENBQUNPLE9BQU9DO1lBQ1IsbUZBQW1GO1lBQ25GLElBQUlBLE1BQU16QyxVQUFVLElBQUksQ0FBQ3FDLFNBQVM7Z0JBQzlCSyxTQUFTQyxnQkFBZ0IsQ0FBQy9CLFdBQVdnQztnQkFDckNGLFNBQVNDLGdCQUFnQixDQUFDOUIsU0FBU2dDO1lBQ3ZDO1lBQ0EsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRSxHQUFHVixVQUFVRCxNQUFNRSxPQUFPLENBQUMsRUFBRSxHQUFHRjtZQUMxRCxNQUFNekIsS0FBS1csZ0JBQWdCO2dCQUFDd0I7Z0JBQVNDO2FBQVEsRUFBRU4sTUFBTTFDLGFBQWE7WUFDbEUwQyxNQUFNTyx5QkFBeUIsSUFDM0JQLE1BQU1PLHlCQUF5QixDQUFDO2dCQUFFWjtZQUFNO1lBQzVDLE9BQU9hLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHVixRQUFRbEMsZUFBZTtnQkFBRUUsU0FBU0csR0FBR3dDLEtBQUs7Z0JBQUl4QztnQkFBSUYsT0FBTzJCLE1BQU1nQixTQUFTLElBQUk7WUFBRTtRQUN2STtJQUNKO0lBQ0EsTUFBTVIsU0FBUyxDQUFDUjtRQUNaSCxJQUFJLENBQUNPLE9BQU9DO1lBQ1IsTUFBTUosVUFBVSxhQUFhRDtZQUM3QiwyREFBMkQ7WUFDM0QsdUJBQXVCO1lBQ3ZCLElBQUlDLFdBQVdELE1BQU1FLE9BQU8sQ0FBQ0MsTUFBTSxHQUFHLEdBQUc7Z0JBQ3JDLE9BQU9DO1lBQ1g7WUFDQSwrQ0FBK0M7WUFDL0MsSUFBSUosTUFBTWdCLFNBQVMsR0FBR1osTUFBTS9CLEtBQUssR0FBR2dDLE1BQU12QyxhQUFhLEVBQUU7Z0JBQ3JELE9BQU9zQyxNQUFNOUIsT0FBTyxHQUFHdUMsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHVixRQUFRO29CQUFFOUIsU0FBUztnQkFBTSxLQUFLOEI7WUFDekY7WUFDQSxNQUFNLEVBQUVNLE9BQU8sRUFBRUMsT0FBTyxFQUFFLEdBQUdWLFVBQVVELE1BQU1FLE9BQU8sQ0FBQyxFQUFFLEdBQUdGO1lBQzFELE1BQU0sQ0FBQ1IsR0FBR0csRUFBRSxHQUFHVCxnQkFBZ0I7Z0JBQUN3QjtnQkFBU0M7YUFBUSxFQUFFTixNQUFNMUMsYUFBYTtZQUN0RSxNQUFNcUIsU0FBU1EsSUFBSVksTUFBTTdCLEVBQUUsQ0FBQyxFQUFFO1lBQzlCLE1BQU1VLFNBQVNVLElBQUlTLE1BQU03QixFQUFFLENBQUMsRUFBRTtZQUM5QixNQUFNTyxPQUFPUSxLQUFLMkIsR0FBRyxDQUFDakM7WUFDdEIsTUFBTUQsT0FBT08sS0FBSzJCLEdBQUcsQ0FBQ2hDO1lBQ3RCLE1BQU1pQyxPQUFPLENBQUNsQixNQUFNZ0IsU0FBUyxJQUFJLEtBQUtaLE1BQU0vQixLQUFLO1lBQ2pELE1BQU04QyxXQUFXN0IsS0FBSzhCLElBQUksQ0FBQ3RDLE9BQU9BLE9BQU9DLE9BQU9BLFFBQVNtQyxDQUFBQSxRQUFRO1lBQ2pFLE1BQU1HLE9BQU87Z0JBQUNyQyxTQUFVa0MsQ0FBQUEsUUFBUTtnQkFBSWpDLFNBQVVpQyxDQUFBQSxRQUFRO2FBQUc7WUFDekQsTUFBTUksTUFBTXpDLGFBQWFDLE1BQU1DLE1BQU1DLFFBQVFDO1lBQzdDLGdGQUFnRjtZQUNoRixNQUFNeEIsUUFBUSxPQUFPNEMsTUFBTTVDLEtBQUssS0FBSyxXQUMvQjRDLE1BQU01QyxLQUFLLEdBQ1g0QyxNQUFNNUMsS0FBSyxDQUFDNkQsSUFBSUMsV0FBVyxHQUFHLElBQzVCL0QsYUFBYUMsS0FBSztZQUMxQixJQUFJcUIsT0FBT3JCLFNBQVNzQixPQUFPdEIsU0FBUyxDQUFDMkMsTUFBTTlCLE9BQU8sRUFDOUMsT0FBTzhCO1lBQ1gsTUFBTW9CLFlBQVk7Z0JBQ2QxQztnQkFDQUM7Z0JBQ0FDO2dCQUNBQztnQkFDQXFDO2dCQUNBdEI7Z0JBQ0E3QixPQUFPaUMsTUFBTWpDLEtBQUs7Z0JBQ2xCQyxTQUFTZ0MsTUFBTWhDLE9BQU87Z0JBQ3RCK0M7Z0JBQ0FFO1lBQ0o7WUFDQSx3REFBd0Q7WUFDeERHLFVBQVVyRCxLQUFLLElBQUlrQyxNQUFNb0IsWUFBWSxJQUFJcEIsTUFBTW9CLFlBQVksQ0FBQ0Q7WUFDNUQsNEJBQTRCO1lBQzVCbkIsTUFBTXFCLFNBQVMsSUFBSXJCLE1BQU1xQixTQUFTLENBQUNGO1lBQ25DLDZFQUE2RTtZQUM3RSwwQ0FBMEM7WUFDMUMsSUFBSUcsc0JBQXNCO1lBQzFCLElBQUl0QixNQUFNcUIsU0FBUyxJQUNmckIsTUFBTXVCLFFBQVEsSUFDZHZCLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRWlCLElBQUksQ0FBQyxDQUFDLEVBQUU7Z0JBQ3pCSyxzQkFBc0I7WUFDMUI7WUFDQSxJQUFJQSx1QkFDQXRCLE1BQU0zQyxvQkFBb0IsSUFDMUIyQyxNQUFNeEMsVUFBVSxJQUNoQm1DLE1BQU02QixVQUFVLEVBQUU7Z0JBQ2xCN0IsTUFBTThCLGNBQWM7WUFDeEI7WUFDQSxPQUFPakIsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHVixRQUFRO2dCQUMzQyw0QkFBNEI7Z0JBQzVCakMsT0FBTztnQkFBT3FEO2dCQUFXbEQsU0FBUztZQUFLO1FBQy9DO0lBQ0o7SUFDQSxNQUFNeUQsUUFBUSxDQUFDL0I7UUFDWEgsSUFBSSxDQUFDTyxPQUFPQztZQUNSLElBQUltQjtZQUNKLElBQUlwQixNQUFNOUIsT0FBTyxJQUFJOEIsTUFBTW9CLFNBQVMsRUFBRTtnQkFDbEMsdURBQXVEO2dCQUN2RCxJQUFJeEIsTUFBTWdCLFNBQVMsR0FBR1osTUFBTS9CLEtBQUssR0FBR2dDLE1BQU12QyxhQUFhLEVBQUU7b0JBQ3JEMEQsWUFBWVgsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHVixNQUFNb0IsU0FBUyxHQUFHO3dCQUFFeEI7b0JBQU07b0JBQ3RFSyxNQUFNdUIsUUFBUSxJQUFJdkIsTUFBTXVCLFFBQVEsQ0FBQ0o7b0JBQ2pDLE1BQU1RLGNBQWMzQixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVtQixVQUFVRixHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUNyRFUsZUFBZUEsWUFBWVI7Z0JBQy9CO1lBQ0osT0FDSztnQkFDRG5CLE1BQU00QixLQUFLLElBQUk1QixNQUFNNEIsS0FBSyxDQUFDO29CQUFFakM7Z0JBQU07WUFDdkM7WUFDQUssTUFBTTZCLHFCQUFxQixJQUFJN0IsTUFBTTZCLHFCQUFxQixDQUFDO2dCQUFFbEM7WUFBTTtZQUNuRSxPQUFPYSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR1YsUUFBUWxDLGVBQWU7Z0JBQUVzRDtZQUFVO1FBQzVGO0lBQ0o7SUFDQSxNQUFNVyxlQUFlO1FBQ2pCLHdDQUF3QztRQUN4QzdCLFNBQVM4QixtQkFBbUIsQ0FBQzVELFdBQVdnQztRQUN4Q0YsU0FBUzhCLG1CQUFtQixDQUFDM0QsU0FBU2dDO0lBQzFDO0lBQ0EsTUFBTUEsT0FBTyxDQUFDNEI7UUFDVkY7UUFDQUosTUFBTU07SUFDVjtJQUNBOzs7Ozs7Ozs7OztLQVdDLEdBQ0QsTUFBTUMsY0FBYyxDQUFDQyxJQUFJbEM7UUFDckIsSUFBSW1DLFVBQVUsS0FBUTtRQUN0QixJQUFJRCxNQUFNQSxHQUFHaEMsZ0JBQWdCLEVBQUU7WUFDM0IsTUFBTWtDLGNBQWM1QixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUd0RCxhQUFhUSxpQkFBaUIsR0FBR3FDLE1BQU1yQyxpQkFBaUI7WUFDNUcsNENBQTRDO1lBQzVDLE1BQU0wRSxNQUFNO2dCQUNSO29CQUFDOUQ7b0JBQVltQjtvQkFBUzBDO2lCQUFZO2dCQUNsQyxtRUFBbUU7Z0JBQ25FO29CQUNJOUQ7b0JBQ0E2QjtvQkFDQUssT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHMkIsY0FBZXBDLE1BQU0zQyxvQkFBb0IsR0FBRzt3QkFBRU8sU0FBUztvQkFBTSxJQUFJLENBQUM7aUJBQ3JHO2dCQUNEO29CQUFDUztvQkFBVXFEO29CQUFPVTtpQkFBWTthQUNqQztZQUNEQyxJQUFJQyxPQUFPLENBQUMsQ0FBQyxDQUFDTixHQUFHTyxHQUFHQyxFQUFFLEdBQUtOLEdBQUdoQyxnQkFBZ0IsQ0FBQzhCLEdBQUdPLEdBQUdDO1lBQ3JELHFGQUFxRjtZQUNyRkwsVUFBVSxJQUFNRSxJQUFJQyxPQUFPLENBQUMsQ0FBQyxDQUFDTixHQUFHTyxFQUFFLEdBQUtMLEdBQUdILG1CQUFtQixDQUFDQyxHQUFHTztRQUN0RTtRQUNBLE9BQU9KO0lBQ1g7SUFDQSxNQUFNTSxRQUFRLENBQUNQO1FBQ1gsZ0dBQWdHO1FBQ2hHLG1CQUFtQjtRQUNuQixJQUFJQSxPQUFPLE1BQ1A7UUFDSjFDLElBQUksQ0FBQ08sT0FBT0M7WUFDUixtREFBbUQ7WUFDbkQsSUFBSUQsTUFBTW1DLEVBQUUsS0FBS0EsSUFDYixPQUFPbkM7WUFDWCxNQUFNMkMsV0FBVyxDQUFDO1lBQ2xCLHdEQUF3RDtZQUN4RCxJQUFJM0MsTUFBTW1DLEVBQUUsSUFBSW5DLE1BQU1tQyxFQUFFLEtBQUtBLE1BQU1uQyxNQUFNNEMsWUFBWSxFQUFFO2dCQUNuRDVDLE1BQU00QyxZQUFZO2dCQUNsQkQsU0FBU0MsWUFBWSxHQUFHLEtBQUs7WUFDakM7WUFDQSx3Q0FBd0M7WUFDeEMsSUFBSTNDLE1BQU14QyxVQUFVLElBQUkwRSxJQUFJO2dCQUN4QlEsU0FBU0MsWUFBWSxHQUFHVixZQUFZQyxJQUFJbEM7WUFDNUM7WUFDQSwwRUFBMEU7WUFDMUUsT0FBT1EsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdWLFFBQVE7Z0JBQUVtQztZQUFHLElBQUlRO1FBQzFFO0lBQ0o7SUFDQSxtREFBbUQ7SUFDbkQsTUFBTUUsU0FBUztRQUNYQyxLQUFLSjtJQUNUO0lBQ0EsNENBQTRDO0lBQzVDLElBQUloRCxhQUFhbEMsVUFBVSxFQUFFO1FBQ3pCcUYsT0FBT0UsV0FBVyxHQUFHcEQ7SUFDekI7SUFDQSxPQUFPO1FBQUNrRDtRQUFRWDtLQUFZO0FBQ2hDO0FBQ0EsU0FBU2MscUJBQXFCaEQsS0FBSyxFQUFFQyxLQUFLLEVBQUVnRCxhQUFhLEVBQUVmLFdBQVc7SUFDbEUscUZBQXFGO0lBQ3JGLElBQUksQ0FBQ2pDLE1BQU14QyxVQUFVLElBQUksQ0FBQ3VDLE1BQU1tQyxFQUFFLEVBQUU7UUFDaEMsSUFBSW5DLE1BQU00QyxZQUFZLEVBQUU7WUFDcEI1QyxNQUFNNEMsWUFBWTtRQUN0QjtRQUNBLE9BQU9uQyxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdWLFFBQVE7WUFBRTRDLGNBQWNNO1FBQVU7SUFDN0U7SUFDQSwrRUFBK0U7SUFDL0UsSUFBSSxDQUFDbEQsTUFBTTRDLFlBQVksRUFBRTtRQUNyQixPQUFPbkMsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHVixRQUFRO1lBQUU0QyxjQUFjVixZQUFZbEMsTUFBTW1DLEVBQUUsRUFBRWxDO1FBQU87SUFDaEc7SUFDQSxnR0FBZ0c7SUFDaEcsNkZBQTZGO0lBQzdGLGdCQUFnQjtJQUNoQixJQUFJQSxNQUFNM0Msb0JBQW9CLEtBQUsyRixjQUFjM0Ysb0JBQW9CLElBQ2pFMkMsTUFBTXJDLGlCQUFpQixDQUFDQyxPQUFPLEtBQUtvRixjQUFjckYsaUJBQWlCLENBQUNDLE9BQU8sRUFBRTtRQUM3RW1DLE1BQU00QyxZQUFZO1FBQ2xCLE9BQU9uQyxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdWLFFBQVE7WUFBRTRDLGNBQWNWLFlBQVlsQyxNQUFNbUMsRUFBRSxFQUFFbEM7UUFBTztJQUNoRztJQUNBLE9BQU9EO0FBQ1g7QUFDQSxTQUFTbUQsYUFBYUMsT0FBTztJQUN6QixNQUFNLEVBQUU1RixVQUFVLEVBQUUsR0FBRzRGO0lBQ3ZCLE1BQU1DLGlCQUFpQnRHLHlDQUFZLENBQUMwRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHNUM7SUFDdEQsTUFBTXlGLGlCQUFpQnhHLHlDQUFZLENBQUMwRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHdEQ7SUFDdEQsZ0NBQWdDO0lBQ2hDLE1BQU02RixnQkFBZ0JsRyx5Q0FBWSxDQUFDMEQsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRzZDLGVBQWVDLE9BQU87SUFDM0VQLGNBQWNPLE9BQU8sR0FBRy9DLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUc2QyxlQUFlQyxPQUFPO0lBQ2hFLHlDQUF5QztJQUN6Q0QsZUFBZUMsT0FBTyxHQUFHL0MsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHdEQsZUFBZWdHO0lBQ3hFLHVDQUF1QztJQUN2QyxJQUFJSztJQUNKLElBQUtBLGNBQWNyRyxhQUFjO1FBQzdCLElBQUltRyxlQUFlQyxPQUFPLENBQUNDLFdBQVcsS0FBSyxLQUFLLEdBQUc7WUFDL0NGLGVBQWVDLE9BQU8sQ0FBQ0MsV0FBVyxHQUFHckcsWUFBWSxDQUFDcUcsV0FBVztRQUNqRTtJQUNKO0lBQ0EsTUFBTSxDQUFDQyxVQUFVeEIsWUFBWSxHQUFHbkYsMENBQWEsQ0FBQyxJQUFNeUMsWUFBWSxDQUFDb0UsY0FBaUJQLGVBQWVHLE9BQU8sR0FBR0ksWUFBWVAsZUFBZUcsT0FBTyxFQUFFRCxlQUFlQyxPQUFPLEdBQUk7WUFBRWhHO1FBQVcsSUFBSTtRQUFDQTtLQUFXO0lBQ3RNNkYsZUFBZUcsT0FBTyxHQUFHUixxQkFBcUJLLGVBQWVHLE9BQU8sRUFBRUQsZUFBZUMsT0FBTyxFQUFFUCxjQUFjTyxPQUFPLEVBQUV0QjtJQUNySCxPQUFPd0I7QUFDWDtBQUUrQyxDQUMvQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3dpcGVhYmxlL2VzL2luZGV4LmpzP2Y4YWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBMRUZUID0gXCJMZWZ0XCI7XG5jb25zdCBSSUdIVCA9IFwiUmlnaHRcIjtcbmNvbnN0IFVQID0gXCJVcFwiO1xuY29uc3QgRE9XTiA9IFwiRG93blwiO1xuXG4vKiBnbG9iYWwgZG9jdW1lbnQgKi9cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkZWx0YTogMTAsXG4gICAgcHJldmVudFNjcm9sbE9uU3dpcGU6IGZhbHNlLFxuICAgIHJvdGF0aW9uQW5nbGU6IDAsXG4gICAgdHJhY2tNb3VzZTogZmFsc2UsXG4gICAgdHJhY2tUb3VjaDogdHJ1ZSxcbiAgICBzd2lwZUR1cmF0aW9uOiBJbmZpbml0eSxcbiAgICB0b3VjaEV2ZW50T3B0aW9uczogeyBwYXNzaXZlOiB0cnVlIH0sXG59O1xuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIGZpcnN0OiB0cnVlLFxuICAgIGluaXRpYWw6IFswLCAwXSxcbiAgICBzdGFydDogMCxcbiAgICBzd2lwaW5nOiBmYWxzZSxcbiAgICB4eTogWzAsIDBdLFxufTtcbmNvbnN0IG1vdXNlTW92ZSA9IFwibW91c2Vtb3ZlXCI7XG5jb25zdCBtb3VzZVVwID0gXCJtb3VzZXVwXCI7XG5jb25zdCB0b3VjaEVuZCA9IFwidG91Y2hlbmRcIjtcbmNvbnN0IHRvdWNoTW92ZSA9IFwidG91Y2htb3ZlXCI7XG5jb25zdCB0b3VjaFN0YXJ0ID0gXCJ0b3VjaHN0YXJ0XCI7XG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oYWJzWCwgYWJzWSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBpZiAoYWJzWCA+IGFic1kpIHtcbiAgICAgICAgaWYgKGRlbHRhWCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBSSUdIVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTEVGVDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgICByZXR1cm4gRE9XTjtcbiAgICB9XG4gICAgcmV0dXJuIFVQO1xufVxuZnVuY3Rpb24gcm90YXRlWFlCeUFuZ2xlKHBvcywgYW5nbGUpIHtcbiAgICBpZiAoYW5nbGUgPT09IDApXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgY29uc3QgYW5nbGVJblJhZGlhbnMgPSAoTWF0aC5QSSAvIDE4MCkgKiBhbmdsZTtcbiAgICBjb25zdCB4ID0gcG9zWzBdICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpICsgcG9zWzFdICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgIGNvbnN0IHkgPSBwb3NbMV0gKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucykgLSBwb3NbMF0gKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZXJzKHNldCwgaGFuZGxlclByb3BzKSB7XG4gICAgY29uc3Qgb25TdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBpc1RvdWNoID0gXCJ0b3VjaGVzXCIgaW4gZXZlbnQ7XG4gICAgICAgIC8vIGlmIG1vcmUgdGhhbiBhIHNpbmdsZSB0b3VjaCBkb24ndCB0cmFjaywgZm9yIG5vdy4uLlxuICAgICAgICBpZiAoaXNUb3VjaCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldCgoc3RhdGUsIHByb3BzKSA9PiB7XG4gICAgICAgICAgICAvLyBzZXR1cCBtb3VzZSBsaXN0ZW5lcnMgb24gZG9jdW1lbnQgdG8gdHJhY2sgc3dpcGUgc2luY2Ugc3dpcGUgY2FuIGxlYXZlIGNvbnRhaW5lclxuICAgICAgICAgICAgaWYgKHByb3BzLnRyYWNrTW91c2UgJiYgIWlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG1vdXNlTW92ZSwgb25Nb3ZlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG1vdXNlVXAsIG9uVXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBpc1RvdWNoID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuICAgICAgICAgICAgY29uc3QgeHkgPSByb3RhdGVYWUJ5QW5nbGUoW2NsaWVudFgsIGNsaWVudFldLCBwcm9wcy5yb3RhdGlvbkFuZ2xlKTtcbiAgICAgICAgICAgIHByb3BzLm9uVG91Y2hTdGFydE9yT25Nb3VzZURvd24gJiZcbiAgICAgICAgICAgICAgICBwcm9wcy5vblRvdWNoU3RhcnRPck9uTW91c2VEb3duKHsgZXZlbnQgfSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgaW5pdGlhbFN0YXRlKSwgeyBpbml0aWFsOiB4eS5zbGljZSgpLCB4eSwgc3RhcnQ6IGV2ZW50LnRpbWVTdGFtcCB8fCAwIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICBzZXQoKHN0YXRlLCBwcm9wcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNUb3VjaCA9IFwidG91Y2hlc1wiIGluIGV2ZW50O1xuICAgICAgICAgICAgLy8gRGlzY291bnQgYSBzd2lwZSBpZiBhZGRpdGlvbmFsIHRvdWNoZXMgYXJlIHByZXNlbnQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGEgc3dpcGUgaGFzIHN0YXJ0ZWQuXG4gICAgICAgICAgICBpZiAoaXNUb3VjaCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBzd2lwZSBoYXMgZXhjZWVkZWQgZHVyYXRpb24gc3RvcCB0cmFja2luZ1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRpbWVTdGFtcCAtIHN0YXRlLnN0YXJ0ID4gcHJvcHMuc3dpcGVEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5zd2lwaW5nID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgc3dpcGluZzogZmFsc2UgfSkgOiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gaXNUb3VjaCA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IHJvdGF0ZVhZQnlBbmdsZShbY2xpZW50WCwgY2xpZW50WV0sIHByb3BzLnJvdGF0aW9uQW5nbGUpO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFYID0geCAtIHN0YXRlLnh5WzBdO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFZID0geSAtIHN0YXRlLnh5WzFdO1xuICAgICAgICAgICAgY29uc3QgYWJzWCA9IE1hdGguYWJzKGRlbHRhWCk7XG4gICAgICAgICAgICBjb25zdCBhYnNZID0gTWF0aC5hYnMoZGVsdGFZKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSAoZXZlbnQudGltZVN0YW1wIHx8IDApIC0gc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCB2ZWxvY2l0eSA9IE1hdGguc3FydChhYnNYICogYWJzWCArIGFic1kgKiBhYnNZKSAvICh0aW1lIHx8IDEpO1xuICAgICAgICAgICAgY29uc3Qgdnh2eSA9IFtkZWx0YVggLyAodGltZSB8fCAxKSwgZGVsdGFZIC8gKHRpbWUgfHwgMSldO1xuICAgICAgICAgICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKGFic1gsIGFic1ksIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgICAgIC8vIGlmIHN3aXBlIGlzIHVuZGVyIGRlbHRhIGFuZCB3ZSBoYXZlIG5vdCBzdGFydGVkIHRvIHRyYWNrIGEgc3dpcGU6IHNraXAgdXBkYXRlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IHR5cGVvZiBwcm9wcy5kZWx0YSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgID8gcHJvcHMuZGVsdGFcbiAgICAgICAgICAgICAgICA6IHByb3BzLmRlbHRhW2Rpci50b0xvd2VyQ2FzZSgpXSB8fFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvcHMuZGVsdGE7XG4gICAgICAgICAgICBpZiAoYWJzWCA8IGRlbHRhICYmIGFic1kgPCBkZWx0YSAmJiAhc3RhdGUuc3dpcGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBldmVudERhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWJzWCxcbiAgICAgICAgICAgICAgICBhYnNZLFxuICAgICAgICAgICAgICAgIGRlbHRhWCxcbiAgICAgICAgICAgICAgICBkZWx0YVksXG4gICAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGZpcnN0OiBzdGF0ZS5maXJzdCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiBzdGF0ZS5pbml0aWFsLFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5LFxuICAgICAgICAgICAgICAgIHZ4dnksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY2FsbCBvblN3aXBlU3RhcnQgaWYgcHJlc2VudCBhbmQgaXMgZmlyc3Qgc3dpcGUgZXZlbnRcbiAgICAgICAgICAgIGV2ZW50RGF0YS5maXJzdCAmJiBwcm9wcy5vblN3aXBlU3RhcnQgJiYgcHJvcHMub25Td2lwZVN0YXJ0KGV2ZW50RGF0YSk7XG4gICAgICAgICAgICAvLyBjYWxsIG9uU3dpcGluZyBpZiBwcmVzZW50XG4gICAgICAgICAgICBwcm9wcy5vblN3aXBpbmcgJiYgcHJvcHMub25Td2lwaW5nKGV2ZW50RGF0YSk7XG4gICAgICAgICAgICAvLyB0cmFjayBpZiBhIHN3aXBlIGlzIGNhbmNlbGFibGUgKGhhbmRsZXIgZm9yIHN3aXBpbmcgb3Igc3dpcGVkKGRpcikgZXhpc3RzKVxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgaWYgbmVlZGVkXG4gICAgICAgICAgICBsZXQgY2FuY2VsYWJsZVBhZ2VTd2lwZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHByb3BzLm9uU3dpcGluZyB8fFxuICAgICAgICAgICAgICAgIHByb3BzLm9uU3dpcGVkIHx8XG4gICAgICAgICAgICAgICAgcHJvcHNbYG9uU3dpcGVkJHtkaXJ9YF0pIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlUGFnZVN3aXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxhYmxlUGFnZVN3aXBlICYmXG4gICAgICAgICAgICAgICAgcHJvcHMucHJldmVudFNjcm9sbE9uU3dpcGUgJiZcbiAgICAgICAgICAgICAgICBwcm9wcy50cmFja1RvdWNoICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgaXMgbm93IGFsd2F5cyBmYWxzZVxuICAgICAgICAgICAgICAgIGZpcnN0OiBmYWxzZSwgZXZlbnREYXRhLCBzd2lwaW5nOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHNldCgoc3RhdGUsIHByb3BzKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXZlbnREYXRhO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN3aXBpbmcgJiYgc3RhdGUuZXZlbnREYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgc3dpcGUgaXMgbGVzcyB0aGFuIGR1cmF0aW9uIGZpcmUgc3dpcGVkIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50aW1lU3RhbXAgLSBzdGF0ZS5zdGFydCA8IHByb3BzLnN3aXBlRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5ldmVudERhdGEpLCB7IGV2ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5vblN3aXBlZCAmJiBwcm9wcy5vblN3aXBlZChldmVudERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvblN3aXBlZERpciA9IHByb3BzW2BvblN3aXBlZCR7ZXZlbnREYXRhLmRpcn1gXTtcbiAgICAgICAgICAgICAgICAgICAgb25Td2lwZWREaXIgJiYgb25Td2lwZWREaXIoZXZlbnREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5vblRhcCAmJiBwcm9wcy5vblRhcCh7IGV2ZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMub25Ub3VjaEVuZE9yT25Nb3VzZVVwICYmIHByb3BzLm9uVG91Y2hFbmRPck9uTW91c2VVcCh7IGV2ZW50IH0pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIGluaXRpYWxTdGF0ZSksIHsgZXZlbnREYXRhIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNsZWFuVXBNb3VzZSA9ICgpID0+IHtcbiAgICAgICAgLy8gc2FmZSB0byBqdXN0IGNhbGwgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlTW92ZSwgb25Nb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVVwLCBvblVwKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uVXAgPSAoZSkgPT4ge1xuICAgICAgICBjbGVhblVwTW91c2UoKTtcbiAgICAgICAgb25FbmQoZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgcGFzc2l2ZSBvbiB0b3VjaE1vdmUgZGVwZW5kcyBvbiBgcHJldmVudFNjcm9sbE9uU3dpcGVgOlxuICAgICAqIC0gdHJ1ZSA9PiB7IHBhc3NpdmU6IGZhbHNlIH1cbiAgICAgKiAtIGZhbHNlID0+IHsgcGFzc2l2ZTogdHJ1ZSB9IC8vIERlZmF1bHRcbiAgICAgKlxuICAgICAqIE5PVEU6IFdoZW4gcHJldmVudFNjcm9sbE9uU3dpcGUgaXMgdHJ1ZSwgd2UgYXR0ZW1wdCB0byBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgc2Nyb2xsLlxuICAgICAqXG4gICAgICogcHJvcHMudG91Y2hFdmVudE9wdGlvbnMgY2FuIGFsc28gYmUgc2V0IGZvciBhbGwgdG91Y2ggZXZlbnQgbGlzdGVuZXJzLFxuICAgICAqIGJ1dCBmb3IgYHRvdWNobW92ZWAgc3BlY2lmaWNhbGx5IHdoZW4gYHByZXZlbnRTY3JvbGxPblN3aXBlYCBpdCB3aWxsXG4gICAgICogc3VwZXJzZWRlIGFuZCBmb3JjZSBwYXNzaXZlIHRvIGZhbHNlLlxuICAgICAqXG4gICAgICovXG4gICAgY29uc3QgYXR0YWNoVG91Y2ggPSAoZWwsIHByb3BzKSA9PiB7XG4gICAgICAgIGxldCBjbGVhbnVwID0gKCkgPT4geyB9O1xuICAgICAgICBpZiAoZWwgJiYgZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgYmFzZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcy50b3VjaEV2ZW50T3B0aW9ucyksIHByb3BzLnRvdWNoRXZlbnRPcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGF0dGFjaCB0b3VjaCBldmVudCBsaXN0ZW5lcnMgYW5kIGhhbmRsZXJzXG4gICAgICAgICAgICBjb25zdCB0bHMgPSBbXG4gICAgICAgICAgICAgICAgW3RvdWNoU3RhcnQsIG9uU3RhcnQsIGJhc2VPcHRpb25zXSxcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50U2Nyb2xsT25Td2lwZSBvcHRpb24gc3VwZXJzZWRlcyB0b3VjaEV2ZW50T3B0aW9ucy5wYXNzaXZlXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICB0b3VjaE1vdmUsXG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZSxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlT3B0aW9ucyksIChwcm9wcy5wcmV2ZW50U2Nyb2xsT25Td2lwZSA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IHt9KSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBbdG91Y2hFbmQsIG9uRW5kLCBiYXNlT3B0aW9uc10sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGxzLmZvckVhY2goKFtlLCBoLCBvXSkgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihlLCBoLCBvKSk7XG4gICAgICAgICAgICAvLyByZXR1cm4gcHJvcGVybHkgc2NvcGVkIGNsZWFudXAgbWV0aG9kIGZvciByZW1vdmluZyBsaXN0ZW5lcnMsIG9wdGlvbnMgbm90IHJlcXVpcmVkXG4gICAgICAgICAgICBjbGVhbnVwID0gKCkgPT4gdGxzLmZvckVhY2goKFtlLCBoXSkgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgfTtcbiAgICBjb25zdCBvblJlZiA9IChlbCkgPT4ge1xuICAgICAgICAvLyBcImlubGluZVwiIHJlZiBmdW5jdGlvbnMgYXJlIGNhbGxlZCB0d2ljZSBvbiByZW5kZXIsIG9uY2Ugd2l0aCBudWxsIHRoZW4gYWdhaW4gd2l0aCBET00gZWxlbWVudFxuICAgICAgICAvLyBpZ25vcmUgbnVsbCBoZXJlXG4gICAgICAgIGlmIChlbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0KChzdGF0ZSwgcHJvcHMpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzYW1lIERPTSBlbCBhcyBwcmV2aW91cyBqdXN0IHJldHVybiBzdGF0ZVxuICAgICAgICAgICAgaWYgKHN0YXRlLmVsID09PSBlbClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBhZGRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgLy8gaWYgbmV3IERPTSBlbCBjbGVhbiB1cCBvbGQgRE9NIGFuZCByZXNldCBjbGVhblVwVG91Y2hcbiAgICAgICAgICAgIGlmIChzdGF0ZS5lbCAmJiBzdGF0ZS5lbCAhPT0gZWwgJiYgc3RhdGUuY2xlYW5VcFRvdWNoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xlYW5VcFRvdWNoKCk7XG4gICAgICAgICAgICAgICAgYWRkU3RhdGUuY2xlYW5VcFRvdWNoID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSBhdHRhY2ggaWYgd2Ugd2FudCB0byB0cmFjayB0b3VjaFxuICAgICAgICAgICAgaWYgKHByb3BzLnRyYWNrVG91Y2ggJiYgZWwpIHtcbiAgICAgICAgICAgICAgICBhZGRTdGF0ZS5jbGVhblVwVG91Y2ggPSBhdHRhY2hUb3VjaChlbCwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RvcmUgZXZlbnQgYXR0YWNoZWQgRE9NIGVsIGZvciBjb21wYXJpc29uLCBjbGVhbiB1cCwgYW5kIHJlLWF0dGFjaG1lbnRcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IGVsIH0pLCBhZGRTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gc2V0IHJlZiBjYWxsYmFjayB0byBhdHRhY2ggdG91Y2ggZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICByZWY6IG9uUmVmLFxuICAgIH07XG4gICAgLy8gaWYgdHJhY2sgbW91c2UgYXR0YWNoIG1vdXNlIGRvd24gbGlzdGVuZXJcbiAgICBpZiAoaGFuZGxlclByb3BzLnRyYWNrTW91c2UpIHtcbiAgICAgICAgb3V0cHV0Lm9uTW91c2VEb3duID0gb25TdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIFtvdXRwdXQsIGF0dGFjaFRvdWNoXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zaWVudFN0YXRlKHN0YXRlLCBwcm9wcywgcHJldmlvdXNQcm9wcywgYXR0YWNoVG91Y2gpIHtcbiAgICAvLyBpZiB0cmFja1RvdWNoIGlzIG9mZiBvciB0aGVyZSBpcyBubyBlbCwgdGhlbiByZW1vdmUgaGFuZGxlcnMgaWYgbmVjZXNzYXJ5IGFuZCBleGl0XG4gICAgaWYgKCFwcm9wcy50cmFja1RvdWNoIHx8ICFzdGF0ZS5lbCkge1xuICAgICAgICBpZiAoc3RhdGUuY2xlYW5VcFRvdWNoKSB7XG4gICAgICAgICAgICBzdGF0ZS5jbGVhblVwVG91Y2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgY2xlYW5VcFRvdWNoOiB1bmRlZmluZWQgfSk7XG4gICAgfVxuICAgIC8vIHRyYWNrVG91Y2ggaXMgb24sIHNvIGlmIHRoZXJlIGFyZSBubyBoYW5kbGVycyBhdHRhY2hlZCwgYXR0YWNoIHRoZW0gYW5kIGV4aXRcbiAgICBpZiAoIXN0YXRlLmNsZWFuVXBUb3VjaCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgY2xlYW5VcFRvdWNoOiBhdHRhY2hUb3VjaChzdGF0ZS5lbCwgcHJvcHMpIH0pO1xuICAgIH1cbiAgICAvLyB0cmFja1RvdWNoIGlzIG9uIGFuZCBoYW5kbGVycyBhcmUgYWxyZWFkeSBhdHRhY2hlZCwgc28gaWYgcHJldmVudFNjcm9sbE9uU3dpcGUgY2hhbmdlcyB2YWx1ZSxcbiAgICAvLyByZW1vdmUgYW5kIHJlYXR0YWNoIGhhbmRsZXJzICh0aGlzIGlzIHJlcXVpcmVkIHRvIHVwZGF0ZSB0aGUgcGFzc2l2ZSBvcHRpb24gd2hlbiBhdHRhY2hpbmdcbiAgICAvLyB0aGUgaGFuZGxlcnMpXG4gICAgaWYgKHByb3BzLnByZXZlbnRTY3JvbGxPblN3aXBlICE9PSBwcmV2aW91c1Byb3BzLnByZXZlbnRTY3JvbGxPblN3aXBlIHx8XG4gICAgICAgIHByb3BzLnRvdWNoRXZlbnRPcHRpb25zLnBhc3NpdmUgIT09IHByZXZpb3VzUHJvcHMudG91Y2hFdmVudE9wdGlvbnMucGFzc2l2ZSkge1xuICAgICAgICBzdGF0ZS5jbGVhblVwVG91Y2goKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IGNsZWFuVXBUb3VjaDogYXR0YWNoVG91Y2goc3RhdGUuZWwsIHByb3BzKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlU3dpcGVhYmxlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYWNrTW91c2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhbnNpZW50U3RhdGUgPSBSZWFjdC51c2VSZWYoT2JqZWN0LmFzc2lnbih7fSwgaW5pdGlhbFN0YXRlKSk7XG4gICAgY29uc3QgdHJhbnNpZW50UHJvcHMgPSBSZWFjdC51c2VSZWYoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzKSk7XG4gICAgLy8gdHJhY2sgcHJldmlvdXMgcmVuZGVyZWQgcHJvcHNcbiAgICBjb25zdCBwcmV2aW91c1Byb3BzID0gUmVhY3QudXNlUmVmKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zaWVudFByb3BzLmN1cnJlbnQpKTtcbiAgICBwcmV2aW91c1Byb3BzLmN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LCB0cmFuc2llbnRQcm9wcy5jdXJyZW50KTtcbiAgICAvLyB1cGRhdGUgY3VycmVudCByZW5kZXIgcHJvcHMgJiBkZWZhdWx0c1xuICAgIHRyYW5zaWVudFByb3BzLmN1cnJlbnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcyksIG9wdGlvbnMpO1xuICAgIC8vIEZvcmNlIGRlZmF1bHRzIGZvciBjb25maWcgcHJvcGVydGllc1xuICAgIGxldCBkZWZhdWx0S2V5O1xuICAgIGZvciAoZGVmYXVsdEtleSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHRyYW5zaWVudFByb3BzLmN1cnJlbnRbZGVmYXVsdEtleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHJhbnNpZW50UHJvcHMuY3VycmVudFtkZWZhdWx0S2V5XSA9IGRlZmF1bHRQcm9wc1tkZWZhdWx0S2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbaGFuZGxlcnMsIGF0dGFjaFRvdWNoXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0SGFuZGxlcnMoKHN0YXRlU2V0dGVyKSA9PiAodHJhbnNpZW50U3RhdGUuY3VycmVudCA9IHN0YXRlU2V0dGVyKHRyYW5zaWVudFN0YXRlLmN1cnJlbnQsIHRyYW5zaWVudFByb3BzLmN1cnJlbnQpKSwgeyB0cmFja01vdXNlIH0pLCBbdHJhY2tNb3VzZV0pO1xuICAgIHRyYW5zaWVudFN0YXRlLmN1cnJlbnQgPSB1cGRhdGVUcmFuc2llbnRTdGF0ZSh0cmFuc2llbnRTdGF0ZS5jdXJyZW50LCB0cmFuc2llbnRQcm9wcy5jdXJyZW50LCBwcmV2aW91c1Byb3BzLmN1cnJlbnQsIGF0dGFjaFRvdWNoKTtcbiAgICByZXR1cm4gaGFuZGxlcnM7XG59XG5cbmV4cG9ydCB7IERPV04sIExFRlQsIFJJR0hULCBVUCwgdXNlU3dpcGVhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkxFRlQiLCJSSUdIVCIsIlVQIiwiRE9XTiIsImRlZmF1bHRQcm9wcyIsImRlbHRhIiwicHJldmVudFNjcm9sbE9uU3dpcGUiLCJyb3RhdGlvbkFuZ2xlIiwidHJhY2tNb3VzZSIsInRyYWNrVG91Y2giLCJzd2lwZUR1cmF0aW9uIiwiSW5maW5pdHkiLCJ0b3VjaEV2ZW50T3B0aW9ucyIsInBhc3NpdmUiLCJpbml0aWFsU3RhdGUiLCJmaXJzdCIsImluaXRpYWwiLCJzdGFydCIsInN3aXBpbmciLCJ4eSIsIm1vdXNlTW92ZSIsIm1vdXNlVXAiLCJ0b3VjaEVuZCIsInRvdWNoTW92ZSIsInRvdWNoU3RhcnQiLCJnZXREaXJlY3Rpb24iLCJhYnNYIiwiYWJzWSIsImRlbHRhWCIsImRlbHRhWSIsInJvdGF0ZVhZQnlBbmdsZSIsInBvcyIsImFuZ2xlIiwiYW5nbGVJblJhZGlhbnMiLCJNYXRoIiwiUEkiLCJ4IiwiY29zIiwic2luIiwieSIsImdldEhhbmRsZXJzIiwic2V0IiwiaGFuZGxlclByb3BzIiwib25TdGFydCIsImV2ZW50IiwiaXNUb3VjaCIsInRvdWNoZXMiLCJsZW5ndGgiLCJzdGF0ZSIsInByb3BzIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwib25Nb3ZlIiwib25VcCIsImNsaWVudFgiLCJjbGllbnRZIiwib25Ub3VjaFN0YXJ0T3JPbk1vdXNlRG93biIsIk9iamVjdCIsImFzc2lnbiIsInNsaWNlIiwidGltZVN0YW1wIiwiYWJzIiwidGltZSIsInZlbG9jaXR5Iiwic3FydCIsInZ4dnkiLCJkaXIiLCJ0b0xvd2VyQ2FzZSIsImV2ZW50RGF0YSIsIm9uU3dpcGVTdGFydCIsIm9uU3dpcGluZyIsImNhbmNlbGFibGVQYWdlU3dpcGUiLCJvblN3aXBlZCIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsIm9uRW5kIiwib25Td2lwZWREaXIiLCJvblRhcCIsIm9uVG91Y2hFbmRPck9uTW91c2VVcCIsImNsZWFuVXBNb3VzZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwiYXR0YWNoVG91Y2giLCJlbCIsImNsZWFudXAiLCJiYXNlT3B0aW9ucyIsInRscyIsImZvckVhY2giLCJoIiwibyIsIm9uUmVmIiwiYWRkU3RhdGUiLCJjbGVhblVwVG91Y2giLCJvdXRwdXQiLCJyZWYiLCJvbk1vdXNlRG93biIsInVwZGF0ZVRyYW5zaWVudFN0YXRlIiwicHJldmlvdXNQcm9wcyIsInVuZGVmaW5lZCIsInVzZVN3aXBlYWJsZSIsIm9wdGlvbnMiLCJ0cmFuc2llbnRTdGF0ZSIsInVzZVJlZiIsInRyYW5zaWVudFByb3BzIiwiY3VycmVudCIsImRlZmF1bHRLZXkiLCJoYW5kbGVycyIsInVzZU1lbW8iLCJzdGF0ZVNldHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-swipeable/es/index.js\n");

/***/ })

};
;